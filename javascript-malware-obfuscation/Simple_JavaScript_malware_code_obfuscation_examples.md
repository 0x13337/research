## Simple JavaScript malware code obfuscation examples

A couple of days ago my colleague form my company founds a piece of malicious JavaScript on his Windows machine. Luckily, it did not run and did not harm his system.

I decided to take a look at it and go through the code. Below is some of simple, but still interesting methods to obfuscate JavaScript code.

## First look

If you open file ```do_not_run.js``` from this repository in text editor (and I __strongly suggest you not to run it if you're on Windows machine__ :) ) - you'll see a big mess. Hard to read, hard to figure out what's going on - but it's still valid and working JavaScript code.

How it's even possible?

### Entry point - IIFE

Everything starts from top-level IIFE (Immediately Invoked Function Expression). This is a way to run code in JavaScript (eg. function) without calling it directly.

Consider example:

```javascript
function hello(message) {
	console.log(message)
}
```

If you try to run this code, nothing will happen. To make it work, you have to call function ```hello()``` passing some message to it:

```javascript
function hello(message) {
	console.log(message)
}

hello('This is test')
```

Now, you should be able to see ```This is test``` message displayed in your browser (or Node) console.

Let's make IIFE from this code:

```javascript
(function hello(message) {
	console.log(message)
})('This is test')
```

And some magic happen - even without calling ```hello()``` function, this piece of code works. How it's possible?

* parenthesis around function definition makes a valid JavaScript expression from it. Expression is the simplest piece of code returns some value (like ```2+2```).
* parenthesis with ```This is test``` __runs__ the function passing an argument to it. Technically, ```(fn(x){})(x)``` is equivalent of ```fn(x)``` definition and call in one.

--

IIFE recommended read

https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20%26%20closures/ch3.md#invoking-function-expressions-immediately

--


In our malware sample we have similar call:

```javascript
(function(quhuvu6) {

	// ...
	
}("41553a304f0b442551284206" + "672651014d1e1a60127" + ...```

This causes malware runs on its own passing some very, very long ASCII string as an argument for IIFE function. Then, first line inside this function is run:

```javascript
var defiq = cicuza(quhuvu6);
```

The result saved in variable ```defiq``` is an array of decimal values, with about 9000 elements. Function, which transforms passed ```quhuvu6``` ASCII string into this array, uses couple of tricks, which now we'll analyze in details.


### Basic obfuscation methods

First, take a look at ```ciciza()``` function, before we'll go through and simplify it to more clean and readable version:

```javascript
function cicuza(syhri) {
        var fahomyfo = [];
        for (var segovmiw4 = parseInt((0).toString(36)) /*CN1b367Z19XZqi8XgI67*/ ; segovmiw4 < syhri["l" + ("F", "T", "H", "e") + "n" + ("G", "n", "O", "g") + (29).toString(36) + ("u", "X", "U", "p", "h")]; segovmiw4 += parseInt((2).toString(36))) {
            fahomyfo[("E", "w", "f", "F", "p") + ("G", "i", "L", "u") + "s" + "h"](parseInt(syhri["s" + "u" + "b" + "s" + ("M", "h", "M", "U", "f", "t") + ("M", "q", "r")](segovmiw4, (85, 19, 84, 9, 2)), parseInt((42).toString(0x24)) /*uShFAoMcgqPvcds6w2xD*/ ));
        }
        return fahomyfo;
    };
    
```

First step - rename ```fahomyfo``` to something meaningful. Names like this are very common in malware - it's just some way to hide real purpose of each variable or function.

In ```cicuza()``` variable ```fahomyfo``` id declared as an array and then, after some logic in ```for``` loop - returned as a result.
So let's name it ```result```:

```javascript
function cicuza(syhri) {
        var result = [];
        for (var segovmiw4 = parseInt((0).toString(36)) /*CN1b367Z19XZqi8XgI67*/ ; segovmiw4 < syhri["l" + ("F", "T", "H", "e") + "n" + ("G", "n", "O", "g") + (29).toString(36) + ("u", "X", "U", "p", "h")]; segovmiw4 += parseInt((2).toString(36))) {
            result[("E", "w", "f", "F", "p") + ("G", "i", "L", "u") + "s" + "h"](parseInt(syhri["s" + "u" + "b" + "s" + ("M", "h", "M", "U", "f", "t") + ("M", "q", "r")](segovmiw4, (85, 19, 84, 9, 2)), parseInt((42).toString(0x24)) /*uShFAoMcgqPvcds6w2xD*/ ));
        }
        return result;
    };

```

Ok, now, let's see what's going on in ```for``` loop. First part is to define initial value of variable which controls how many iterations should be performed:

```javascript
for (var segovmiw4 = parseInt((0).toString(36)) /*CN1b367Z19XZqi8XgI67*/ ; ....
```

So, what ```parseInt((0).toString(36))``` does?

First call is ```(0).toString(36)``` - this code contains several operations:

* ```(0)``` is an expression, which value is number 0
* ```.toString(36)``` is a method which returns String representation of JavaScript object. Every object in JavaScript contains this method. When ```toString()``` is called on primitives, like 0 in this case, this primitive value is converted into object (of type Number), then toString() is called on this object and finally new primitive (string) is returned.

When ```toString()``` is called on Number object, additional argument can be passed. This argument is an integer between 2 and 36 specifying the base to use for representing numeric values. So, if ```toString(36)``` is called, argument represents base 36 (Hexatrigesimal system with digits represented by ASCII 0-9 and a-z).
Because 0 in any system is still 0, ```(0).toString(36)``` returns 0.

* second call, ```parseInt(0)``` returns 0 as well. ```parseInt()``` is a function which parses any passed string into Integer and returns it or, if such conversion is not possible, returns ```NaN``` (which is JavaScript representation of ```Not a Number``` value). In this case, it's just 0 parsed to Integer - results in 0 itself.

Finally, ```parseInt((0).toString(36))``` is just a way to represent 0. but did you see how many operations has to be done? This is what code obfuscation in JavaScript is all about - to make code as complicated as it's possible even if all we need is just 0.

Let's also rename ```segovmiw4``` into ```i```, which is popular name for iterator variable inside ```for``` loops.

So after our first analysis, our code becomes:

```javascript
function cicuza(syhri) {
        var result = [];
        for (var i = 0; i < syhri["l" + ("F", "T", "H", "e") + "n" + ("G", "n", "O", "g") + (29).toString(36) + ("u", "X", "U", "p", "h")]; i += parseInt((2).toString(36))) {
            result[("E", "w", "f", "F", "p") + ("G", "i", "L", "u") + "s" + "h"](parseInt(syhri["s" + "u" + "b" + "s" + ("M", "h", "M", "U", "f", "t") + ("M", "q", "r")](i, (85, 19, 84, 9, 2)), parseInt((42).toString(0x24)) /*uShFAoMcgqPvcds6w2xD*/ ));
        }
        return result;
    };

```

--

Number.toString() documentation

http://devdocs.io/javascript/global_objects/number/tostring

Hexatrigesimal system converter

http://www.calculand.com/unit-converter/zahlen.php?zs=36

--

Now, let's focus on what's exactly going on in this piece of code:

```javascript
i < syhri["l" + ("F", "T", "H", "e") + "n" + ("G", "n", "O", "g") + (29).toString(36) + ("u", "X", "U", "p", "h")];
```

We know that ```syhri``` is string. As we know, we can read strings using indexes like in ```Array``` type. ```String[0]``` means first character of the string, ```String[1]``` second character and so on.

So 


We can rename ```syhri``` into something friendly, like ```val```.

